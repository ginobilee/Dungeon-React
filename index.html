<!DOCTYPE html>
<html>
  <head>
    <title>Dungeon-Free Code Camp challenge</title>
    <meta charset='UTF-8'>

    <script src='js/react.min.js'></script>
    <script src='js/react-dom.min.js'></script>
    <script src='js/browser.min.js'></script>


    <link href="css/bootstrap.min.css" rel='stylesheet' />
    <link href='css/style.css' rel='stylesheet' />
  </head>

  <body>
    <div id='root'></div>
  </body>
  <script type='text/babel'>
    const bloodVal=30,UPGRADBLOOD=50;//each green cell add 30 blood
    const soldierC1={
      attack:10,//one hit get 10 blood
      blood:10//one has 20 blood
    },soldierC2={
      attack:20,
      blood:20
    },soldierC3={
      attack:30,
      blood:30
    },soldierC4={
      attack:40,
      blood:60
    },soldierC5={
      attack:50,
      blood:100
    },soldierId=[soldierC1,soldierC2,soldierC3,soldierC4,soldierC5];
    const layers=[{//info for layer 1
      soldiers:[10,5,0,0,0],//index is soldiers' id,value is number
      blood:10,//10 blood cells,each
    },{//info for layer 2
      soldiers:[0,10,5,0,0],//index is soldiers' id,value is number
      blood:10,//10 blood cells,each
    },{//info for layer 1
      soldiers:[0,0,10,5,0],//index is soldiers' id,value is number
      blood:10,//10 blood cells,each
    },{//info for layer 1
      soldiers:[0,0,0,10,5],//index is soldiers' id,value is number
      blood:10,//10 blood cells,each
    }];
    const weapons={
      0:{name:'Stick',attack:10},1:{name:'Stone',attack:20},2:{name:'Knife',attack:30},3:{name:'Pistol',attack:60},4:{name:'Rifle',attack:100}
    },upgradeNeed={1:100,2:200,3:300,4:400,5:500};
    let soldiersInfo={},bossLoc=[],bossAtt=40;
    let bossBlood=2000;

      var Info = (props) => {
        return <div className='message'>
                <span >Health: {props.health}</span>
                <span >Weapon: {weapons[props.weapon].name}</span>
                <span >Attack: {props.attack}</span>
                <span >Level: {props.level+1}</span>
                <span >Next Level: {props.nextLevel}</span>
                <span >Layer: {props.layer+1}</span>
              </div>;
      };

      var GamePad = (props) => {
      	console.log(Date.now()+':son will update');
        let cellState = props.cellState,maskArr=props.maskArr,tempValue,len=cellState[0].length;
        const map = cellState.map(function(ele,ind){
           let cellRow = ele.map(function(e,i){
               tempValue=cellState[ind][i];let cn='';
               if(tempValue==0){
                 cn='cell';
               }else if(tempValue==1){
                 cn='cell white';
               }else if (tempValue==3) {
                 cn='cell purple';
               }else if (tempValue==5) {
                 cn='cell orange';
               }else if (tempValue==8) {
                 cn='cell blue';
               }else if (tempValue==20) {
                 cn='cell green';
               }else if (tempValue==44) {
                 cn='cell boss';
               }else if (tempValue>49) {
                 cn='cell red';
               }else{
                 cn='cell';
               }
               return (<div className={cn} key={ind*len+i} data-key={ind*len+i}></div>);
             },this);
           return <div className='cellRow' key={ind}>{cellRow}</div>;
         },this);
        const mask = maskArr.map(function(ele,ind){
            let maskRow = ele.map(function(e,i){
                tempValue=maskArr[ind][i];
                return (<div className={tempValue==1?'maskcell':'maskcell black'} key={ind*len+i} data-key={ind*len+i}></div>);
              },this);
            return <div className='cellRow' key={ind}>{maskRow}</div>;
          },this);
        const test = maskArr[0].map(function(e,i){
                tempValue=maskArr[0][i];
                return (<div className='maskcell'>{i}</div>);
        },this);
        //get the map div offset
        let userRow=props.userAdd.i,offsetTop,mapHeight=90;
        //console.log(userRow);
        if(userRow<15){
          offsetTop=0;
        }else if(userRow>mapHeight-15){
          offsetTop=-(mapHeight-30)*12;
        }else{
          offsetTop=(15-userRow)*12;
        }
        let topOff={
          top:offsetTop+'px'
        };
        return <div className='stage'>
                  <div className='map' style={topOff}>
                    {map}
                  </div>
                  <div className='mask'>
                    {mask}
                  </div>
              </div>;
      };

      class GameManage extends React.Component{
       constructor(){
         super();
         this.addRooms=this.addRooms.bind(this);
         this.geneSoldiers=this.geneSoldiers.bind(this);
         this.geneBloods=this.geneBloods.bind(this);
         this.geneWeapon=this.geneWeapon.bind(this);
         this.geneUser=this.geneUser.bind(this);
         this.geneMask=this.geneMask.bind(this);
         this.genePass=this.genePass.bind(this);
         this.toggle=this.toggle.bind(this);
         this.move=this.move.bind(this);
         this.restart=this.restart.bind(this);
         this.build=this.build.bind(this);
         this.geneBoss=this.geneBoss.bind(this);

         let newState=this.build(0);

         this.state=(newState);
       }
       build(layerNum){
         let mapWidth=90,mapHeight=90,cellState=[],i,j,rooms=[],room={};
         for(i=0;i<mapHeight;i++){
           let tempRow=[];
           for(j=0;j<mapWidth;j++){
             tempRow.push(0);
           }
           cellState.push(tempRow);
         }
         //generateFirstRoom,'1' for room cell
         for(i=Math.floor(mapHeight/3);i<Math.floor(mapHeight/3)+9;i++){
           for(j=Math.floor(mapWidth/3);j<Math.floor(mapWidth/3)+9;j++){
             cellState[i][j]=1;
           }
         }
         room={
           origin_col:Math.floor(mapWidth/3),
           origin_row:Math.floor(mapHeight/3),
           cols:9,
           rows:9
         };
         rooms.push(room);
         this.addRooms(cellState,rooms);
         this.geneSoldiers(cellState,rooms,layerNum);
         if(layerNum==4){
         		this.geneBoss(cellState,rooms);
         }
         this.geneBloods(cellState,rooms,layerNum);
         this.geneWeapon(cellState,rooms);
         this.genePass(cellState,rooms);
         let userAdd=this.geneUser(cellState,rooms);
         //generate mask array,whose size is 30X90
         let maskArr=[];
         for(i=0;i<30;i++){
           let tempRow=[];
           for(j=0;j<mapWidth;j++){
             tempRow.push(0);
           }
           maskArr.push(tempRow);
         }
         this.geneMask(maskArr,userAdd);
         if(layerNum==0){
	         return {
	           cellState:cellState,
	           health:100,
	           weapon:0,
	           attack:10,
	           level:0,
	           nextLevel:100,
	           layer:layerNum,
	           userAdd:userAdd,
	           maskArr:maskArr,
	           trans:false
	         }
	       }else{//只更新需要更新的：cellstate，maskState，layer，userAdd，
	       	 	 return {cellState:cellState,
					           layer:layerNum,
					           userAdd:userAdd,
					           maskArr:maskArr
					         }
	       }
       }
       addRooms(cellState,rooms){
         let roomNum=rooms.length,parentRI=Math.floor(Math.random()*roomNum),parentRoom=rooms[parentRI],colMin=6,colRange=7,rowMin=7,rowRange=13;
         let newCols=Math.ceil(Math.random()*colRange+colMin),newRows=Math.ceil(rowMin+Math.random()*rowRange);//6-10 for new room length,20 for new room height
         let rnFasade=Math.floor(Math.random()*4),newOriginRow,newOriginCol,newEndRow,newEndCol,pStart,pEnd,passi,passj;//0 for top,1 for right,2 for bottom,3 for left
         switch(rnFasade){
           case 0:
             newOriginRow=parentRoom.origin_row-newRows-1;
             newOriginCol=parentRoom.origin_col-newCols+1+Math.floor(Math.random()*(parentRoom.cols+newCols-1));
             newEndCol=newOriginCol+newCols-1;
             passi=parentRoom.origin_row-1;
             pStart=Math.max(parentRoom.origin_col,newOriginCol);
             pEnd=Math.min(parentRoom.origin_col+parentRoom.cols-1,newOriginCol+newCols-1);
             passj=pStart+Math.ceil(Math.random()*(pEnd-pStart));
             //newOriginCol=newEndCol-newCols;
             break;
           case 1:
            newOriginRow=parentRoom.origin_row-newRows+1+Math.floor(Math.random()*(parentRoom.rows+newRows-1));
            newOriginCol=parentRoom.origin_col+parentRoom.cols+1;
            newEndRow=newOriginRow+newRows-1;
            passj=newOriginCol-1;
            pStart=Math.max(parentRoom.origin_row,newOriginRow);
            pEnd=Math.min(parentRoom.origin_row+parentRoom.rows-1,newOriginRow+newRows-1);
            passi=pStart+Math.ceil(Math.random()*(pEnd-pStart));
            break;
          case 2:
            newOriginRow=parentRoom.origin_row+parentRoom.rows+1;
            newOriginCol=parentRoom.origin_col-newCols+1+Math.floor(Math.random()*(parentRoom.cols+newCols-1));
            passi=newOriginRow-1;
            pStart=Math.max(parentRoom.origin_col,newOriginCol);
            pEnd=Math.min(parentRoom.origin_col+parentRoom.cols-1,newOriginCol+newCols-1);
            passj=pStart+Math.ceil(Math.random()*(pEnd-pStart));
            break;
          case 3:
            newEndCol=parentRoom.origin_col-2;
            newOriginCol=newEndCol-newCols+1;
            newOriginRow=parentRoom.origin_row-newRows+1+Math.floor(Math.random()*(parentRoom.rows+newRows-1));
            passj=parentRoom.origin_col-1;
            pStart=Math.max(parentRoom.origin_row,newOriginRow);
            pEnd=Math.min(parentRoom.origin_row+parentRoom.rows-1,newOriginRow+newRows-1);
            passi=pStart+Math.ceil(Math.random()*(pEnd-pStart));
            break;
         }
         let i=0,j=0,used=false;
         outer:
         for(i=newOriginRow;i<newOriginRow+newRows;i++){
           for(j=newOriginCol;j<newOriginCol+newRows;j++){
             if(i<0 || i>(cellState.length-1) || j<0 || j>(cellState[0].length-1) || cellState[i][j]!=0){
               used=true;
               break outer;
             }
           }
         }
         if(!used){
           let room={
             origin_col:newOriginCol,
             origin_row:newOriginRow,
             cols:newCols,
             rows:newRows
           };
           for(i=newOriginRow;i<newOriginRow+newRows;i++){
             for(j=newOriginCol;j<newOriginCol+newCols;j++){
               cellState[i][j]=1;
             }
           }
           //console.log(passi+':'+passj);
           if(cellState[passi][passj]==0){
             cellState[passi][passj]=1;
           }
           rooms.push(room);
           if(rooms.length<20){
             this.addRooms(cellState,rooms);
           }
         }else{
           this.addRooms(cellState,rooms);
         }
       }
       geneSoldiers(cellState,rooms,num){
         let soldiers=layers[num].soldiers,i=0,j=0;
         for(i=0;i<soldiers.length;i++){
           if(soldiers[i]>0){
             let rnRoom,celli,cellj;
             for(j=0;j<soldiers[i];j++){
               rnRoom=Math.floor(Math.random()*rooms.length);
               celli=rooms[rnRoom].origin_row+Math.ceil(Math.random()*(rooms[rnRoom].rows-1));
               cellj=rooms[rnRoom].origin_col+Math.ceil(Math.random()*(rooms[rnRoom].cols-1));
               if(cellState[celli][cellj]==1){
                 let num=50+i*10+j;
                 cellState[celli][cellj]=num;//50 for class 1,11 for class 2...
                 let newSold={
                   i:celli,
                   j:cellj,
                   attack:soldierId[i].attack,
                   blood:soldierId[i].blood
                 };
                 soldiersInfo[num]=newSold;
               }else{
                 j--;
               }
             }
           }
         }
         //console.log(soldiersInfo);
       }
       geneBoss(cellState,rooms){
         let i=0,j=0;
         for(i=0;i<1;i++){
             let rnRoom,celli,cellj;
             for(j=0;j<1;j++){
               rnRoom=Math.floor(Math.random()*rooms.length);
               celli=rooms[rnRoom].origin_row+Math.ceil(Math.random()*(rooms[rnRoom].rows-1));
               cellj=rooms[rnRoom].origin_col+Math.ceil(Math.random()*(rooms[rnRoom].cols-1));
               if(cellState[celli][cellj]==1&&cellState[celli][cellj+1]==1&&cellState[celli+1][cellj]==1&&cellState[celli+1][cellj+1]==1){
                 let num=44;
                 cellState[celli][cellj]=num;//50 for class 1,11 for class 2...
                 cellState[celli][cellj+1]==num;
                 cellState[celli+1][cellj]==num;
                 cellState[celli+1][cellj+1]==num;
                 bossLoc.push({i:celli,j:cellj});
                 bossLoc.push({i:celli,j:cellj+1});
                 bossLoc.push({i:celli+1,j:cellj});
                 bossLoc.push({i:celli+1,j:cellj+1});
               }else{
                 j--;
               }
             }
         }
         //console.log(soldiersInfo);
       }
       geneBloods(cellState,rooms,num){
         let bNum=layers[num].blood,i,rnRoom,celli,cellj;
         for(i=0;i<bNum;i++){
           rnRoom=Math.floor(Math.random()*rooms.length);
           celli=rooms[rnRoom].origin_row+Math.ceil(Math.random()*(rooms[rnRoom].rows-1));
           cellj=rooms[rnRoom].origin_col+Math.ceil(Math.random()*(rooms[rnRoom].cols-1));
           if(cellState[celli][cellj]==1){
             cellState[celli][cellj]=20;//20 for blood
           }else{
             i--;
           }
         }
       }
       geneWeapon(cellState,rooms){
         let i,rnRoom,celli,cellj;
         for(i=0;i<1;i++){
           rnRoom=Math.floor(Math.random()*rooms.length);
           celli=rooms[rnRoom].origin_row+Math.ceil(Math.random()*(rooms[rnRoom].rows-1));
           cellj=rooms[rnRoom].origin_col+Math.ceil(Math.random()*(rooms[rnRoom].cols-1));
           if(cellState[celli][cellj]==1){
             cellState[celli][cellj]=5;//5 for weapon
           }else{
             i--;
           }
         }
       }
       genePass(cellState,rooms){
       	 let i,rnRoom,celli,cellj;
         for(i=0;i<1;i++){
           rnRoom=Math.floor(Math.random()*rooms.length);
           celli=rooms[rnRoom].origin_row+Math.ceil(Math.random()*(rooms[rnRoom].rows-1));
           cellj=rooms[rnRoom].origin_col+Math.ceil(Math.random()*(rooms[rnRoom].cols-1));
           if(cellState[celli][cellj]==1){
             cellState[celli][cellj]=3;//3 for pass
           }else{
             i--;
           }
         }
       }
       geneUser(cellState,rooms){
         let i,rnRoom,celli,cellj;
         for(i=0;i<1;i++){
           rnRoom=Math.floor(Math.random()*rooms.length);
           celli=rooms[rnRoom].origin_row+Math.ceil(Math.random()*(rooms[rnRoom].rows-1));
           cellj=rooms[rnRoom].origin_col+Math.ceil(Math.random()*(rooms[rnRoom].cols-1));
           if(cellState[celli][cellj]==1){
             cellState[celli][cellj]=8;//8 for user
             return {i:celli,j:cellj};
           }else{
             i--;
           }
         }
       }
       geneMask(maskArr,userAdd){
         let i,j,centeri=userAdd.i,centerj=userAdd.j,mapHeight=90;
         if(centeri>mapHeight-15){
           centeri= centeri-(mapHeight-30);//if user below 105,set mask center lower
         }
         else if(centeri>14){
           centeri=15;
         }
         for(i=0;i<maskArr.length;i++){
         	for(j=0;j<maskArr[0].length;j++){
         		maskArr[i][j]=0;
         	}
         }
         for(i=centeri-5;i<centeri+6;i++){
           for(j=centerj-5;j<centerj+6;j++){
             maskArr[i][j]=1;
           }
         }
         for(i=5;i>2;i--){
           for(j=5;j>7-i;j--){
             maskArr[centeri-i][centerj-j]=0;
             maskArr[centeri-i][centerj+j]=0;
             maskArr[centeri+i][centerj-j]=0;
             maskArr[centeri+i][centerj+j]=0;
           }
         }
       }
       toggle(){
	     	let trans=this.state.trans,maskArr=this.state.maskArr,userAdd=this.state.userAdd,i,j;
	     	if(trans){
       	 	this.geneMask(maskArr,userAdd);
       	 	this.setState({
       	 		maskArr:maskArr,
       	 		trans:!trans
       	 	});
       	}else{
       		for(i=0;i<maskArr.length;i++){
       			for(j=0;j<maskArr[0].length;j++){
       				maskArr[i][j]=1;
       			}
       		}
       		this.setState({
       			maskArr:maskArr,
       	 		trans:!trans
       	 	});
       	}
       }
       move(eve){
       	let kc=eve.keyCode,cellState=this.state.cellState,maskArr=this.state.maskArr,
        userAdd=this.state.userAdd,nowi=userAdd.i,nowj=userAdd.j,newAdd={},trans=this.state.trans,
        valid=true,oldHealth=this.state.health,newHealth,level=this.state.level,
        layer=this.state.layer,mapWidth=90,mapHeight=90;
       	switch(kc){
       		case 37:// left arrow
       			if(nowj>0){
              newAdd={i:nowi,j:nowj-1};
            }
       			break;
          case 38:// up arrow
       			if(nowi>0){
              newAdd={i:nowi-1,j:nowj};
            }
       			break;
          case 39:// right arrow
       			if(nowj<mapWidth){
              newAdd={i:nowi,j:nowj+1};
            }
       			break;
          case 40:// down arrow
            if(nowi<mapHeight){
              newAdd={i:nowi+1,j:nowj};
            }
            break;
          default:
            valid=false;
            break;
       	}
        if(valid){
          if(cellState[newAdd.i][newAdd.j]==1){//action for just move
            //move up
            cellState[nowi][nowj]=1;
            cellState[newAdd.i][newAdd.j]=8;
            if(!trans){
              this.geneMask(maskArr,newAdd);
            }
            this.setState({
              cellState:cellState,
              maskArr:maskArr,
              userAdd:newAdd
            });
          }else if (cellState[newAdd.i][newAdd.j]==3) {//meet a pass
            layer++;
            let newL=this.build(layer);
            this.setState(newL);
          }else if (cellState[newAdd.i][newAdd.j]==5) {//meet a weapon
            let weapon=layer+1,userAtt=this.state.attack;
            userAtt+=weapons[weapon].attack;
            cellState[nowi][nowj]=1;
            cellState[newAdd.i][newAdd.j]=8;
            if(!trans){
              this.geneMask(maskArr,newAdd);
            }
            this.setState({
              cellState:cellState,
              maskArr:maskArr,
              userAdd:newAdd,
              attack:userAtt,
            	weapon:weapon
            });
          }else if(cellState[newAdd.i][newAdd.j]==20){//green blood
            cellState[nowi][nowj]=1;
            cellState[newAdd.i][newAdd.j]=8;
            if(!trans){
              this.geneMask(maskArr,newAdd);
            }
            //console.log(oldHealth);
            newHealth=oldHealth+20;
            this.setState({
              cellState:cellState,
              maskArr:maskArr,
              userAdd:newAdd,
              health:newHealth
            });
          }else if(cellState[newAdd.i][newAdd.j]==44){//meet boss,who has 2000 blood,40 attacks
            let userBlood=this.state.health,userAtt=this.state.attack,
            nextLevel=this.state.nextLevel-bossAtt;
            bossBlood-=userAtt;userBlood-=bossAtt;
            if(userBlood<1){//user dies
              this.setState({
                health:0
              });
            }else if (bossBlood<1){//boss dies
            	if(nextLevel<1){//upgrade
                level+=1;
                nextLevel=upgradeNeed[level];
                userAtt=userAtt+(level+1)*15;//15*level more attack for a upgrade
                userBlood+=UPGRADBLOOD;//50 blood for a upgrade
              }
              cellState[nowi][nowj]=1;
              for(let m=0;m<bossLoc.length;m++){
              	let temp=bossLoc[m];
              	cellState[temp['i']][temp['j']]=1;
              }
              cellState[newAdd.i][newAdd.j]=8;
              if(!trans){
                this.geneMask(maskArr,newAdd);
              }
              this.setState({
                level:level,
                nextLevel:nextLevel,
                attack:userAtt,
                cellState:cellState,
                maskArr:maskArr,
                userAdd:newAdd,
                health:userBlood
              });
            }else{//both alive,just need upgrade health,nextLevel,
              if(nextLevel<1){//upgrade
                level+=1;
                nextLevel=upgradeNeed[level];
                userAtt=userAtt+(level+1)*15;//15*level more attack for a upgrade
                userBlood+=UPGRADBLOOD;//50 blood for a upgrade
              }
              this.setState({
                health:userBlood,
                nextLevel:nextLevel
              })
            }
          }else if(cellState[newAdd.i][newAdd.j]>49){
            let num=cellState[newAdd.i][newAdd.j],userBlood=this.state.health,userAtt=this.state.attack,
            soldierAtt=soldiersInfo[num].attack,soldierBlood=soldiersInfo[num].blood;
            soldierBlood-=userAtt;userBlood-=soldierAtt;
            let nextLevel=this.state.nextLevel-soldierAtt;
            if(userBlood<1){//user dies
              this.setState({
                health:0
              });
            }else if (soldierBlood<1){//soldier dies
              if(nextLevel<1){//upgrade
                level+=1;
                nextLevel=upgradeNeed[level];
                userAtt=userAtt+(level+1)*15;//20*level more attack for a upgrade
                userBlood+=UPGRADBLOOD;//50 blood for a upgrade
              }
              soldiersInfo[num].blood=0;
              cellState[nowi][nowj]=1;
              cellState[newAdd.i][newAdd.j]=8;
              if(!trans){
                this.geneMask(maskArr,newAdd);
              }
              this.setState({
                level:level,
                nextLevel:nextLevel,
                attack:userAtt,
                cellState:cellState,
                maskArr:maskArr,
                userAdd:newAdd,
                health:userBlood
              });
            }else{//both alive,just need upgrade health,soldiersInfo,nextLevel,
              if(nextLevel<1){//upgrade
                level+=1;
                nextLevel=upgradeNeed[level];
                userAtt=userAtt+(level+1)*15;//15*level more attack for a upgrade
                userBlood+=UPGRADBLOOD;//50 blood for a upgrade
              }
              soldiersInfo[num].blood=soldierBlood;
              this.setState({
                health:userBlood,
                nextLevel:nextLevel
              })
            }
          }else{
          }
        }
       }
       restart(){
         let newS=this.build(0);
         this.state=newS;
         this.forceUpdate();
         this.refs.toggle.setAttribute('tabindex',1);
         this.refs.toggle.focus();
       }
       componentDidMount(){
       	this.refs.toggle.setAttribute('tabindex',1);
       	this.refs.toggle.focus();
       }
       componentWillUpdate(){
       	console.log(Date.now()+':update will update');
       }
       componentDidUpdate(){
       	console.log(Date.now()+':update end');
       }
       shouldComponentUpdate(){
         let health=this.state.health;if(health==0){
           return false;
         }else{
           return true;
         }
       }
       render(){
         let health=this.state.health;

          return (
            <div className='content' ref='toggle' tabindex='1' onKeyDown={this.move}>
              <h1 >Dungeon</h1>
              <h3>Kill the boss in layer 4</h3>
              <button onClick={this.toggle} className='btn btn-primary toggle' >TOGGLE</button>
              <Info health={this.state.health} weapon={this.state.weapon} attack={this.state.attack} level={this.state.level} nextLevel={this.state.nextLevel} layer={this.state.layer} />
              <GamePad  userAdd={this.state.userAdd} cellState={this.state.cellState} maskArr={this.state.maskArr} />
              <div className={health==0?'warn':'hide'}><button onClick={this.restart} className='btn btn-primary'>Game Over! Click here to restart!</button></div>
            </div>
          );
       }
    }

    ReactDOM.render(
      <GameManage />,
      document.getElementById('root')
    );

</script>
</html>
